import { decodeSemanticBytes } from '../../../src/lib/glyphDecoding/semanticDecoder';
import { DecodedSemanticInfo } from '../../../src/lib/types';

describe('decodeSemanticBytes', () => {
  it('should decode 8 bytes into semantic info object', () => {
    // Example bytes (would be generated by encodeSemanticsToBytes)
    // This is a simplified example; real encoding is more complex.
    const bytes = new Uint8Array([
      (2 << 4) | (0 << 2), // statement, positive
      128, // complexity ~0.5
      204, // density ~0.8
      (63 & 0x7F) | (1 << 7), // intensity ~0.5, positive valence
      1 | (1 << 2), // temporal, personal
      (31 & 0x3F) | ((2 & 0x03) << 6), // formality ~0.5, directness ~0.66
      (95 & 0x7F) | (1 << 7), // certainty ~0.75, urgent
      0xFF, // version
    ]);

    const decoded: DecodedSemanticInfo = decodeSemanticBytes(bytes);

    expect(decoded.intent).toBe('statement');
    expect(decoded.tone).toBe('positive');
    expect(decoded.complexity).toBeCloseTo(128 / 255);
    expect(decoded.density).toBeCloseTo(204 / 255);
    expect(decoded.emotionalIntensity).toBeCloseTo(63 / 127);
    expect(decoded.emotionalValence).toBe('positive');
    expect(decoded.contextFlags).toEqual(['temporal', 'personal']);
    expect(decoded.formality).toBeCloseTo(31 / 63);
    expect(decoded.directness).toBeCloseTo(2 / 3);
    expect(decoded.certainty).toBeCloseTo(95 / 127);
    expect(decoded.urgent).toBe(true);
    expect(decoded.version).toBe('extended');
  });

  it('should throw error for insufficient byte length', () => {
    expect(() => decodeSemanticBytes(new Uint8Array(7))).toThrow();
  });
});
